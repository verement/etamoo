<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/MOO/Network/Console.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a>
<a name="line-2"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>MOO</span><span class='hs-varop'>.</span><span class='hs-conid'>Network</span><span class='hs-varop'>.</span><span class='hs-conid'>Console</span> <span class='hs-layout'>(</span> <span class='hs-varid'>createConsoleListener</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-3"></a>
<a name="line-4"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span> <span class='hs-layout'>(</span><span class='hs-varid'>forkIO</span><span class='hs-layout'>,</span> <span class='hs-varid'>killThread</span><span class='hs-layout'>)</span>
<a name="line-5"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span><span class='hs-varop'>.</span><span class='hs-conid'>STM</span> <span class='hs-layout'>(</span><span class='hs-conid'>STM</span><span class='hs-layout'>,</span> <span class='hs-conid'>TVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>atomically</span><span class='hs-layout'>,</span> <span class='hs-varid'>readTVar</span><span class='hs-layout'>)</span>
<a name="line-6"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Exception</span> <span class='hs-layout'>(</span><span class='hs-conid'>SomeException</span><span class='hs-layout'>,</span> <span class='hs-varid'>try</span><span class='hs-layout'>)</span>
<a name="line-7"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-varid'>liftM</span><span class='hs-layout'>,</span> <span class='hs-varid'>when</span><span class='hs-layout'>,</span> <span class='hs-varid'>unless</span><span class='hs-layout'>,</span> <span class='hs-varid'>forever</span><span class='hs-layout'>)</span>
<a name="line-8"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span> <span class='hs-layout'>(</span><span class='hs-varid'>lift</span><span class='hs-layout'>)</span>
<a name="line-9"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>IO</span><span class='hs-varop'>.</span><span class='hs-conid'>Class</span> <span class='hs-layout'>(</span><span class='hs-varid'>liftIO</span><span class='hs-layout'>)</span>
<a name="line-10"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>ByteString</span> <span class='hs-layout'>(</span><span class='hs-conid'>ByteString</span><span class='hs-layout'>)</span>
<a name="line-11"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>\\</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>sort</span><span class='hs-layout'>,</span> <span class='hs-varid'>nub</span><span class='hs-layout'>)</span>
<a name="line-12"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>mapMaybe</span><span class='hs-layout'>,</span> <span class='hs-varid'>catMaybes</span><span class='hs-layout'>)</span>
<a name="line-13"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span> <span class='hs-layout'>(</span><span class='hs-conid'>Text</span><span class='hs-layout'>)</span>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span><span class='hs-varop'>.</span><span class='hs-conid'>Encoding</span> <span class='hs-layout'>(</span><span class='hs-varid'>encodeUtf8</span><span class='hs-layout'>)</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Pipes</span> <span class='hs-layout'>(</span><span class='hs-conid'>Producer</span><span class='hs-layout'>,</span> <span class='hs-conid'>Pipe</span><span class='hs-layout'>,</span> <span class='hs-varid'>runEffect</span><span class='hs-layout'>,</span> <span class='hs-varid'>await</span><span class='hs-layout'>,</span> <span class='hs-varid'>yield</span><span class='hs-layout'>,</span> <span class='hs-varid'>for</span><span class='hs-layout'>,</span> <span class='hs-varid'>cat</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varop'>&gt;-&gt;</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Pipes</span><span class='hs-varop'>.</span><span class='hs-conid'>ByteString</span> <span class='hs-layout'>(</span><span class='hs-varid'>stdout</span><span class='hs-layout'>)</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Pipes</span><span class='hs-varop'>.</span><span class='hs-conid'>Concurrent</span> <span class='hs-layout'>(</span><span class='hs-varid'>spawn</span><span class='hs-layout'>,</span> <span class='hs-varid'>unbounded</span><span class='hs-layout'>,</span> <span class='hs-varid'>send</span><span class='hs-layout'>,</span> <span class='hs-varid'>fromInput</span><span class='hs-layout'>,</span> <span class='hs-varid'>toOutput</span><span class='hs-layout'>)</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>System</span><span class='hs-varop'>.</span><span class='hs-conid'>Console</span><span class='hs-varop'>.</span><span class='hs-conid'>Haskeline</span> <span class='hs-layout'>(</span><span class='hs-conid'>InputT</span><span class='hs-layout'>,</span> <span class='hs-conid'>CompletionFunc</span><span class='hs-layout'>,</span> <span class='hs-conid'>Completion</span><span class='hs-conid'>()</span><span class='hs-layout'>,</span>
<a name="line-19"></a>                                 <span class='hs-varid'>runInputT</span><span class='hs-layout'>,</span> <span class='hs-varid'>getInputLine</span><span class='hs-layout'>,</span>
<a name="line-20"></a>                                 <span class='hs-varid'>setComplete</span><span class='hs-layout'>,</span> <span class='hs-varid'>defaultSettings</span><span class='hs-layout'>,</span>
<a name="line-21"></a>                                 <span class='hs-varid'>completeWordWithPrev</span><span class='hs-layout'>,</span> <span class='hs-varid'>simpleCompletion</span><span class='hs-layout'>)</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>System</span><span class='hs-varop'>.</span><span class='hs-conid'>IO</span> <span class='hs-layout'>(</span><span class='hs-varid'>hIsClosed</span><span class='hs-layout'>,</span> <span class='hs-varid'>stdin</span><span class='hs-layout'>)</span>
<a name="line-23"></a>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>HashMap</span><span class='hs-varop'>.</span><span class='hs-conid'>Strict</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>HM</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>IntSet</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>IS</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Text</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>T</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Vector</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>V</span>
<a name="line-28"></a>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MOO</span><span class='hs-varop'>.</span><span class='hs-conid'>Connection</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConnectionHandler</span><span class='hs-layout'>)</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>MOO</span><span class='hs-varop'>.</span><span class='hs-conid'>Network</span> <span class='hs-layout'>(</span><span class='hs-conid'>Point</span><span class='hs-layout'>(</span><span class='hs-conid'>Console</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-31"></a>                                   <span class='hs-conid'>Listener</span><span class='hs-layout'>(</span><span class='hs-varid'>listenerPoint</span><span class='hs-layout'>,</span> <span class='hs-varid'>listenerCancel</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MOO</span><span class='hs-varop'>.</span><span class='hs-conid'>Object</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MOO</span><span class='hs-varop'>.</span><span class='hs-conid'>Task</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MOO</span><span class='hs-varop'>.</span><span class='hs-conid'>Types</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MOO</span><span class='hs-varop'>.</span><span class='hs-conid'>Verb</span>
<a name="line-36"></a>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>MOO</span><span class='hs-varop'>.</span><span class='hs-conid'>String</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Str</span>
<a name="line-38"></a>
<a name="line-39"></a><a name="createConsoleListener"></a><span class='hs-definition'>createConsoleListener</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Listener</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectionHandler</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>Listener</span>
<a name="line-40"></a><span class='hs-definition'>createConsoleListener</span> <span class='hs-varid'>listener</span> <span class='hs-varid'>handler</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-41"></a>  <span class='hs-keyword'>let</span> <span class='hs-conid'>Console</span> <span class='hs-varid'>world'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>listenerPoint</span> <span class='hs-varid'>listener</span>
<a name="line-42"></a>
<a name="line-43"></a>  <span class='hs-varid'>thread</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>forkIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>acceptConnection</span> <span class='hs-varid'>world'</span> <span class='hs-varid'>handler</span>
<a name="line-44"></a>
<a name="line-45"></a>  <span class='hs-varid'>return</span> <span class='hs-varid'>listener</span> <span class='hs-layout'>{</span> <span class='hs-varid'>listenerCancel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>killThread</span> <span class='hs-varid'>thread</span> <span class='hs-layout'>}</span>
<a name="line-46"></a>
<a name="line-47"></a><a name="acceptConnection"></a><span class='hs-definition'>acceptConnection</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TVar</span> <span class='hs-conid'>World</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectionHandler</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>()</span>
<a name="line-48"></a><span class='hs-definition'>acceptConnection</span> <span class='hs-varid'>worldTVar</span> <span class='hs-varid'>handler</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-49"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>connectionName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>STM</span> <span class='hs-conid'>String</span>
<a name="line-50"></a>      <span class='hs-varid'>connectionName</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-str'>"console"</span>
<a name="line-51"></a>
<a name="line-52"></a>  <span class='hs-layout'>(</span><span class='hs-varid'>output</span><span class='hs-layout'>,</span> <span class='hs-varid'>input</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>spawn</span> <span class='hs-varid'>unbounded</span>
<a name="line-53"></a>
<a name="line-54"></a>  <span class='hs-varid'>thread</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>forkIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>runInputT</span> <span class='hs-varid'>defaultSettings</span> <span class='hs-varop'>$</span> <span class='hs-varid'>runEffect</span> <span class='hs-varop'>$</span>
<a name="line-55"></a>    <span class='hs-varid'>consoleInput</span> <span class='hs-varop'>&gt;-&gt;</span> <span class='hs-varid'>writeLines</span> <span class='hs-varop'>&gt;-&gt;</span> <span class='hs-varid'>writeUtf8</span> <span class='hs-varop'>&gt;-&gt;</span> <span class='hs-varid'>toOutput</span> <span class='hs-varid'>output</span>
<a name="line-56"></a>
<a name="line-57"></a>  <span class='hs-varid'>handler</span> <span class='hs-varid'>connectionName</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromInput</span> <span class='hs-varid'>input</span><span class='hs-layout'>,</span> <span class='hs-varid'>stdout</span><span class='hs-layout'>)</span>
<a name="line-58"></a>  <span class='hs-varid'>killThread</span> <span class='hs-varid'>thread</span>
<a name="line-59"></a>
<a name="line-60"></a>  <span class='hs-varid'>eof</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>try</span> <span class='hs-layout'>(</span><span class='hs-varid'>hIsClosed</span> <span class='hs-varid'>stdin</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span>
<a name="line-61"></a>         <span class='hs-varid'>either</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>err</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>err</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SomeException</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>return</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-varid'>return</span>
<a name="line-62"></a>  <span class='hs-varid'>unless</span> <span class='hs-varid'>eof</span> <span class='hs-varop'>$</span> <span class='hs-varid'>acceptConnection</span> <span class='hs-varid'>worldTVar</span> <span class='hs-varid'>handler</span>
<a name="line-63"></a>
<a name="line-64"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>writeLines</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Pipe</span> <span class='hs-conid'>Text</span> <span class='hs-conid'>Text</span> <span class='hs-varid'>m</span> <span class='hs-conid'>()</span>
<a name="line-65"></a>        <span class='hs-varid'>writeLines</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forever</span> <span class='hs-varop'>$</span> <span class='hs-varid'>await</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>yield</span> <span class='hs-varop'>.</span> <span class='hs-varid'>flip</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>snoc</span> <span class='hs-chr'>'\n'</span>
<a name="line-66"></a>
<a name="line-67"></a>        <span class='hs-varid'>writeUtf8</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monad</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Pipe</span> <span class='hs-conid'>Text</span> <span class='hs-conid'>ByteString</span> <span class='hs-varid'>m</span> <span class='hs-conid'>()</span>
<a name="line-68"></a>        <span class='hs-varid'>writeUtf8</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>for</span> <span class='hs-varid'>cat</span> <span class='hs-layout'>(</span><span class='hs-varid'>yield</span> <span class='hs-varop'>.</span> <span class='hs-varid'>encodeUtf8</span><span class='hs-layout'>)</span>
<a name="line-69"></a>
<a name="line-70"></a><a name="consoleInput"></a><span class='hs-definition'>consoleInput</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Producer</span> <span class='hs-conid'>Text</span> <span class='hs-layout'>(</span><span class='hs-conid'>InputT</span> <span class='hs-conid'>IO</span><span class='hs-layout'>)</span> <span class='hs-conid'>()</span>
<a name="line-71"></a><span class='hs-definition'>consoleInput</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop</span>
<a name="line-72"></a>  <span class='hs-keyword'>where</span> <span class='hs-varid'>loop</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-73"></a>          <span class='hs-varid'>maybeLine</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lift</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getInputLine</span> <span class='hs-str'>""</span>
<a name="line-74"></a>          <span class='hs-keyword'>case</span> <span class='hs-varid'>maybeLine</span> <span class='hs-keyword'>of</span>
<a name="line-75"></a>            <span class='hs-conid'>Just</span> <span class='hs-varid'>line</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>yield</span> <span class='hs-layout'>(</span><span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>pack</span> <span class='hs-varid'>line</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>loop</span>
<a name="line-76"></a>            <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-77"></a>
<a name="line-78"></a><span class='hs-comment'>{-
<a name="line-79"></a>  let completion = mooCompletion worldTVar (initialPlayer testFrame)
<a name="line-80"></a>  runInputT (setComplete completion defaultSettings) $
<a name="line-81"></a>    repLoop worldTVar $ addFrame testFrame state
<a name="line-82"></a>
<a name="line-83"></a>mooCompletion :: TVar World -&gt; ObjId -&gt; CompletionFunc IO
<a name="line-84"></a>mooCompletion world player = completeWordWithPrev Nothing sep completions
<a name="line-85"></a>  where sep = " \t.:$"
<a name="line-86"></a>
<a name="line-87"></a>        completions prev word =
<a name="line-88"></a>          liftM (mkCompletions $ null prev) $
<a name="line-89"></a>          runTask =&lt;&lt; newTask world player completionTask
<a name="line-90"></a>          where completionTask =
<a name="line-91"></a>                  getCompletions prev word `catchException` \_ -&gt; return zero
<a name="line-92"></a>
<a name="line-93"></a>        mkCompletions :: Bool -&gt; Maybe Value -&gt; [Completion]
<a name="line-94"></a>        mkCompletions finished (Just (Lst v)) =
<a name="line-95"></a>          mapMaybe (mkCompletion finished) (V.toList v)
<a name="line-96"></a>        mkCompletions _ _ = []
<a name="line-97"></a>
<a name="line-98"></a>        mkCompletion :: Bool -&gt; Value -&gt; Maybe Completion
<a name="line-99"></a>        mkCompletion finished (Str str) =
<a name="line-100"></a>          Just $ (simpleCompletion $ Str.toString str) { isFinished = finished }
<a name="line-101"></a>        mkCompletion _ _ = Nothing
<a name="line-102"></a>
<a name="line-103"></a>        getCompletions :: String -&gt; String -&gt; MOO Value
<a name="line-104"></a>        getCompletions "" word = completeCommandVerb word
<a name="line-105"></a>        getCompletions ('$':_) word = completeProperty word 0
<a name="line-106"></a>        getCompletions ('.':prev) word =
<a name="line-107"></a>          objectForCompletion prev &gt;&gt;= completeProperty word
<a name="line-108"></a>        getCompletions (':':prev) word =
<a name="line-109"></a>          objectForCompletion prev &gt;&gt;= completeVerb word
<a name="line-110"></a>        getCompletions _ word = completeName word
<a name="line-111"></a>
<a name="line-112"></a>        objectForCompletion :: String -&gt; MOO ObjId
<a name="line-113"></a>        objectForCompletion prev = return nothing
<a name="line-114"></a>
<a name="line-115"></a>        completeProperty :: String -&gt; ObjId -&gt; MOO Value
<a name="line-116"></a>        completeProperty word oid = do
<a name="line-117"></a>          maybeObj &lt;- getObject oid
<a name="line-118"></a>          case maybeObj of
<a name="line-119"></a>            Nothing  -&gt; return zero
<a name="line-120"></a>            Just obj -&gt; do
<a name="line-121"></a>              unless (objectPermR obj) $ checkPermission (objectOwner obj)
<a name="line-122"></a>              properties &lt;- liftSTM $ mapM readTVar $
<a name="line-123"></a>                            HM.elems $ objectProperties obj
<a name="line-124"></a>              return $ mkResults word $
<a name="line-125"></a>                map fromId builtinProperties ++ map propertyName properties
<a name="line-126"></a>
<a name="line-127"></a>        completeVerb :: String -&gt; ObjId -&gt; MOO Value
<a name="line-128"></a>        completeVerb word oid = return zero
<a name="line-129"></a>
<a name="line-130"></a>        completeCommandVerb :: String -&gt; MOO Value
<a name="line-131"></a>        completeCommandVerb word = do
<a name="line-132"></a>          objects &lt;- localObjects True
<a name="line-133"></a>          verbs &lt;- concat `liftM` mapM verbsForObject objects
<a name="line-134"></a>          return $ mkResults word $ concatMap simpleVerbNames $
<a name="line-135"></a>            filter isCommandVerb verbs
<a name="line-136"></a>
<a name="line-137"></a>        simpleVerbNames :: Verb -&gt; [StrT]
<a name="line-138"></a>        simpleVerbNames = map removeStar . Str.words . verbNames
<a name="line-139"></a>          where removeStar name =
<a name="line-140"></a>                  let (before, after) = Str.break (== '*') name
<a name="line-141"></a>                  in before `Str.append` if Str.null after
<a name="line-142"></a>                                         then after else Str.tail after
<a name="line-143"></a>
<a name="line-144"></a>        isCommandVerb :: Verb -&gt; Bool
<a name="line-145"></a>        isCommandVerb verb =
<a name="line-146"></a>          not $ verbDirectObject   verb /= ObjNone  &amp;&amp;
<a name="line-147"></a>                verbPreposition    verb == PrepNone &amp;&amp;
<a name="line-148"></a>                verbIndirectObject verb /= ObjNone
<a name="line-149"></a>
<a name="line-150"></a>        verbsForObject :: Object -&gt; MOO [Verb]
<a name="line-151"></a>        verbsForObject obj = do
<a name="line-152"></a>          verbs &lt;- liftSTM $ mapM (readTVar . snd) $ objectVerbs obj
<a name="line-153"></a>          case objectParent obj of
<a name="line-154"></a>            Nothing        -&gt; return verbs
<a name="line-155"></a>            Just parentOid -&gt; do
<a name="line-156"></a>              maybeParent &lt;- getObject parentOid
<a name="line-157"></a>              case maybeParent of
<a name="line-158"></a>                Nothing     -&gt; return verbs
<a name="line-159"></a>                Just parent -&gt; (verbs ++) `liftM` verbsForObject parent
<a name="line-160"></a>
<a name="line-161"></a>        completeName :: String -&gt; MOO Value
<a name="line-162"></a>        completeName word = do
<a name="line-163"></a>          objects &lt;- localObjects False
<a name="line-164"></a>          return $ mkResults word $ map objectName objects ++ ["me", "here"]
<a name="line-165"></a>
<a name="line-166"></a>        localObjects :: Bool -&gt; MOO [Object]
<a name="line-167"></a>        localObjects includeRoom = do
<a name="line-168"></a>          player &lt;- getPlayer
<a name="line-169"></a>          maybePlayer &lt;- getObject player
<a name="line-170"></a>          case maybePlayer of
<a name="line-171"></a>            Nothing      -&gt; return []
<a name="line-172"></a>            Just player' -&gt; do
<a name="line-173"></a>              let holding   = objectContents player'
<a name="line-174"></a>                  maybeRoom = objectLocation player'
<a name="line-175"></a>              roomContents &lt;-
<a name="line-176"></a>                maybe (return IS.empty)
<a name="line-177"></a>                (liftM (maybe IS.empty objectContents) . getObject) maybeRoom
<a name="line-178"></a>              let oids = maybe id (:) (if includeRoom
<a name="line-179"></a>                                       then maybeRoom else Nothing) $
<a name="line-180"></a>                         IS.toList (holding `IS.union` roomContents)
<a name="line-181"></a>              liftM ((player' :) . catMaybes) $
<a name="line-182"></a>                mapM getObject (oids \\ [player])
<a name="line-183"></a>
<a name="line-184"></a>        mkResults :: String -&gt; [StrT] -&gt; Value
<a name="line-185"></a>        mkResults word = stringList . sort . nub . filter isPrefix
<a name="line-186"></a>          where isPrefix name = word' `Str.isPrefixOf` name
<a name="line-187"></a>                word' = Str.fromString word
<a name="line-188"></a>-}</span>
</pre></body>
</html>
